/**
 * @file GameConfig.h
 * @brief Game configuration and result structures for the Octa-Core game engine
 * 
 * This file defines the configuration structures and enums used to control
 * game behavior, win conditions, and safety levels. It also includes the
 * GameResult structure for representing game outcomes.
 * 
 * Created in Phase P1.3 according to SRD v3.2 specifications.
 */

#ifndef OCTA_CORE_GAMECONFIG_H
#define OCTA_CORE_GAMECONFIG_H

#include <string>
#include <optional>
#include "../core/Enums.h"

/**
 * @enum WinCondition
 * @brief Defines the different ways a game can end
 * 
 * The win condition determines how the game logic checks for victory:
 * - ELIMINATION: Game ends when one player has zero cells
 * - TURN_LIMIT_MAJORITY: Game ends after a set number of turns, winner has most cells
 */
enum class WinCondition : uint8_t {
    ELIMINATION,        ///< Victory by eliminating all opponent cells
    TURN_LIMIT_MAJORITY ///< Victory by majority after turn limit reached
};

/**
 * @enum SafetyLevel
 * @brief Defines the level of exception safety and rollback for game operations
 * 
 * This enum controls the robustness of game state management:
 * - VALIDATE_ONLY: Basic validation, no rollback on failure
 * - LIGHT_UNDO: Simple undo mechanism for basic operations
 * - FULL_ROLLBACK: Complete transactional rollback with strong exception safety
 * 
 * For Phase P1.3, we implement VALIDATE_ONLY tier as specified.
 */
enum class SafetyLevel : uint8_t {
    VALIDATE_ONLY,  ///< Basic validation only (Phase P1.3 implementation)
    LIGHT_UNDO,     ///< Simple undo operations (future implementation)
    FULL_ROLLBACK   ///< Full transactional rollback (future implementation)
};

/**
 * @struct GameConfig
 * @brief Configuration parameters for a game session
 * 
 * This structure holds all the settings that control game behavior,
 * including win conditions, turn limits, and safety features.
 * 
 * The configuration is typically set at the start of a game and
 * remains constant throughout the session.
 */
struct GameConfig {
    /// How the game determines victory
    WinCondition winCondition = WinCondition::ELIMINATION;
    
    /// Maximum number of turns before forced end (used with TURN_LIMIT_MAJORITY)
    int turnLimit = 100;
    
    /// Whether chain reactions stop when hitting enemy cells
    bool stopOnEnemy = false;
    
    /// Level of exception safety and rollback protection
    SafetyLevel safetyLevel = SafetyLevel::VALIDATE_ONLY;
    
    /**
     * @brief Default constructor with sensible defaults
     * 
     * Creates a configuration suitable for most games:
     * - Elimination victory condition
     * - 100 turn limit (for timeout protection)
     * - Chain reactions continue through enemy cells
     * - Basic validation safety level
     */
    GameConfig() = default;
    
    /**
     * @brief Constructor with custom parameters
     * @param win The win condition to use
     * @param turns Maximum number of turns
     * @param stopEnemy Whether to stop chains on enemy cells
     * @param safety The safety level for operations
     */
    GameConfig(WinCondition win, int turns, bool stopEnemy, SafetyLevel safety)
        : winCondition(win), turnLimit(turns), stopOnEnemy(stopEnemy), safetyLevel(safety) {}
    
    /**
     * @brief Validates the configuration parameters
     * @return True if the configuration is valid, false otherwise
     * 
     * Checks that:
     * - Turn limit is positive
     * - Win condition is valid for the turn limit setting
     */
    bool isValid() const {
        if (turnLimit <= 0) return false;
        if (winCondition == WinCondition::TURN_LIMIT_MAJORITY && turnLimit < 1) return false;
        return true;
    }
};

/**
 * @struct GameResult
 * @brief Represents the outcome of a completed game
 * 
 * This structure encapsulates all information about how a game ended,
 * including the winner (if any) and a human-readable explanation.
 * 
 * The result is typically generated by the game logic when isGameOver()
 * becomes true and can be used for UI display, statistics, or logging.
 */
struct GameResult {
    /// The winning player, or nullopt for a tie/draw
    std::optional<Player> winner;
    
    /// Human-readable explanation of how the game ended
    std::string reason;
    
    /// The turn number when the game ended
    int finalTurnCount = 0;
    
    /// Final cell counts for statistical purposes
    int player1CellCount = 0;
    int player2CellCount = 0;
    
    /**
     * @brief Default constructor for an incomplete game
     */
    GameResult() = default;
    
    /**
     * @brief Constructor for a game with a clear winner
     * @param winningPlayer The player who won
     * @param endReason Why the game ended
     * @param turnCount The final turn count
     * @param p1Cells Final cell count for Player 1
     * @param p2Cells Final cell count for Player 2
     */
    GameResult(Player winningPlayer, const std::string& endReason, int turnCount, int p1Cells, int p2Cells)
        : winner(winningPlayer), reason(endReason), finalTurnCount(turnCount), 
          player1CellCount(p1Cells), player2CellCount(p2Cells) {}
    
    /**
     * @brief Constructor for a tie/draw game
     * @param endReason Why the game ended in a tie
     * @param turnCount The final turn count
     * @param p1Cells Final cell count for Player 1
     * @param p2Cells Final cell count for Player 2
     */
    GameResult(const std::string& endReason, int turnCount, int p1Cells, int p2Cells)
        : winner(std::nullopt), reason(endReason), finalTurnCount(turnCount),
          player1CellCount(p1Cells), player2CellCount(p2Cells) {}
    
    /**
     * @brief Checks if the game ended in a tie
     * @return True if no winner was determined
     */
    bool isTie() const {
        return !winner.has_value();
    }
    
    /**
     * @brief Gets a formatted string representation of the result
     * @return Human-readable game result summary
     */
    std::string toString() const {
        std::string result = "Game ended after " + std::to_string(finalTurnCount) + " turns: ";
        if (winner.has_value()) {
            result += "Player " + std::to_string(static_cast<int>(winner.value()) + 1) + " wins";
        } else {
            result += "Tie game";
        }
        result += " (" + reason + ")";
        result += " [P1: " + std::to_string(player1CellCount) + ", P2: " + std::to_string(player2CellCount) + "]";
        return result;
    }
};

/**
 * @brief Converts WinCondition enum to string representation
 * @param condition The win condition to convert
 * @return String representation of the win condition
 */
inline const char* winConditionToString(WinCondition condition) {
    switch (condition) {
        case WinCondition::ELIMINATION:        return "ELIMINATION";
        case WinCondition::TURN_LIMIT_MAJORITY: return "TURN_LIMIT_MAJORITY";
        default:                               return "UNKNOWN";
    }
}

/**
 * @brief Converts SafetyLevel enum to string representation
 * @param level The safety level to convert
 * @return String representation of the safety level
 */
inline const char* safetyLevelToString(SafetyLevel level) {
    switch (level) {
        case SafetyLevel::VALIDATE_ONLY:  return "VALIDATE_ONLY";
        case SafetyLevel::LIGHT_UNDO:     return "LIGHT_UNDO";
        case SafetyLevel::FULL_ROLLBACK:  return "FULL_ROLLBACK";
        default:                          return "UNKNOWN";
    }
}

#endif // OCTA_CORE_GAMECONFIG_H 